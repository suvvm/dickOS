# Dickos

这是一个汇编+C语言开发的操作系统

本项目为个人开发os的初次尝试，跟随川合秀实所提供资料进行开发。

当前运行后会读取磁盘10个柱面并执行dickos.sys加载boot引导程序包。

设定16色调色板

初始化GDT & IDT

初始化可编程中断控制器PIC

调用函数boxFill8使用指针操作VRAM显示桌面GUI

在桌面打印DICKOS并显示鼠标坐标

内存分配采取分段式分配方式，以4KB为单位，分配失败时使用鸵鸟算法处理 :laughing:

在桌面打印内存大小与可用内存大小

初始化键盘控制电路并激活鼠标，在鼠标与键盘产生中断时打印相应数据，完成部分键盘中断码识别，当前可用输入英文大小写字母、数字、英文符号，并完成CapsLock NumLock SrollLock与对应键盘led灯状态的改变与识别。

使用图层处理重叠问题

鼠标移动实现，鼠标点击时将改变processA窗口的位置。

实现多进程，采用时间片轮转+多级反馈进行进程调度，初始由主进程完成各功能与设备的初始化，并创建控制台进程，主进程处理键盘鼠标与测试输入窗口processA的中断，按下tab可将当前活动窗口转变为控制台窗口，此时普通字符的中断数据将由主进程发送给控制台进程以实现在控制台窗口的输入活动，再次按下tab可将活动窗口由控制台窗口换回processA测试输入窗口。

完成对fat16文件系统的解析。

控制台指令采用windows风格，当前以实现指令如下

```
mem						检查内存容量与当前内存可用空间
cls						清屏
dir						显示当前目录所有文件信息
type filename			显示指定文件名的文件内容（完成换行符制表表的显示）
applicationName			可用直接使用应用程序名来启动应用程序（自动检测是否为应用程序，开辟应用程序专有内存并创建新的进程以运行应用程序运行结束返回控制台）
```

可以按下shift + F1以强行终止应用程序的运行

当前可运行应用程序如下

```
helloC					使用C语言编写，在逐个控制台打印hello，用于测试系统调用API中打印单个字符
bug1					使用C语言编写在越界的内存处写入ABC，以测试栈异常处理，QEMU有bug如想观察正常结果请真机运行
bug2					使用C语言编写执行死循环以测试shift+f1强制关闭应用程序
bug3					使用C语言编写执行死循环并在控制台打印a以更好的测试shift+f1强制关闭应用程序
helloCS					使用C语言编写，在控制台输出字符串hello,world用于测试系统调用API中打印字符串
winHelo					使用C语言编写，创建新的hello窗口，以测试测试系统调用API绘制窗口功能
winHelo2				使用C语言编写，创建新的hello窗口并在窗口中绘制黄色矩形并显示hello world，以测试测试系统调用API在图层中绘制矩形和在图层中显示字符功能
```

完成一般异常中断处理与栈异常中断处理以阻止尝试恶意破坏dickOS的应用程序，防御测试已完成，测试使用应用程序源码[crack1.c](https://github.com/suvvm/dickOS/blob/master/crack1.c)、[crack2.nas](https://github.com/suvvm/dickOS/blob/master/crack2.nas)、[crack3.nas](https://github.com/suvvm/dickOS/blob/master/crack3.nas)、[crack4.nas](https://github.com/suvvm/dickOS/blob/master/crack4.nas)、[crack5.nas](https://github.com/suvvm/dickOS/blob/master/crack5.nas)依然存在，但其生成的应用程序已经在操作系统中移除，若想测试请手动修改Makefile中的文件生成规则，将其编译为应用程序后复制到fat16文件系统根目录便可使用控制台运行（注：Qemu有bug若想测试防御功能需要真机运行）

# Build

windows：在!cons_nt.bat或!cons_9x.bat（控制台对应目录）中输入make install（目标地址为a:）

# Run

windows：在!cons_nt.bat或!cons_9x.bat（控制台对应目录）中输入make run即可调用QEMU运行

#  Command-line instruction 

```makefile
make img 		# 生成映像文件dickos.img
make run		# 生成必要文件并启动qemu模拟器
make install	# 生成必要文件并将其安装至a驱动器
make clean		# 删除中间文件
make src_only	# 删除中间文件并删除dickos.img映像
```

# Memory distribution

```
0x00000000 ~ 0x000fffff : 启动中使用 之后变为空(1MB) 部分被VRAM与BIOS使用，并不全空
0x00100000 ~ 0x00267fff : 保存软盘内容(1440KB)
0x00268000 ~ 0x0026f7ff : 空(30KB)
0x0026f800 ~ 0x0026ffff : IDT(2KB)
0x00270000 ~ 0x0027ffff : GDT(64KB)
0x00280000 ~ 0x002fffff : bootpack.hrb(512KB)
0x00300000 ~ 0x003fffff : 栈及其他(1MB)
0x00400000 ~			: 空
```

# Thanks

- 川合秀实
- RWFD
- 平木敬太郎
- Kiyoto

# 许可协议原文

```开源协议原文
通俗地说：“这是自由软件，使用前使用后都无须支付任何费用，可以自由使用，也可以复制、修改，以及用于商业目的，但是作者对软件的bug以及因此所造成的损失不负任何责任。”

为了保护软件使用者以及软件修改者、参考者的利益，即便作者将来为该软件中所使用的算法申请专利，也保证不会向使用者收取授权费用。

本协议并不代表作者放弃著作权（仅放弃独家复制发布的权利），使用者可以自由复制并 再次发布本软件的一部分甚至全部内容。使用时无须支付任何费用，对本软件的解析、修改也无须支付任何费用。

适用于本协议的软件，可以无条件地用作商业目的，甚至可以将软件直接有偿出售。

对于以适用于本协议的软件的一部分或全部内容为基础，在此之上所开发的软件（下称“派生物”），可以赋予任何种类的许可协议。即，派生物的作者可以禁止对派生物进行复制，也可以只允许派生物以有偿形式发布。派生物的著作权属于该派生物的生成者，适用于本协 议的软件作者不会对其派生物主张著作权。

在派生物的文档中，没有义务对原始软件的作者进行介绍，但这句话，理所当然地，不意味着禁止这一行为。

在发布派生物时，没有义务取得原始软件作者的同意，但这句话，理所当然地，不意味着禁止这一行为。

作者不对软件的质量作出任何保证，因此，由于使用本软件所造成的损害，或者没有达到所期望的结果，作者不负任何责任。

对于适用于本协议的软件中所使用的技术，除了事先取得作者授权的人以外，禁止其他人对其申请专利。但如果附加了新的技术并生成了派生物，允许对于追加的部分申请专利。作者在将来有可能对软件中的技术申请专利，但保证不会向派生物以及软件的使用收取授权费 用。本保证不仅适用于申请专利之前所生成的派生物，也适用于专利取得后所生成的派生物。

将解析结果汇总并申请专利，需要事先取得作者的同意，但对于申请专利以外的行为，没有任何限制。
```

